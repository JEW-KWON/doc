## SOLID 원칙
 - SOLID 원칙은 객체지향 프로그래밍에서 소프트웨어 설계의 5가지 기본 원칙을 의미합니다. 
   이 원칙들은 소프트웨어의 유지보수성, 확장성, 유연성을 높이는 데 도움을 줍니다. 
   SOLID는 다음과 같은 다섯 가지 원칙으로 구성되어 있습니다.

### 1. 단일책임원칙(Single Responsibility Principle, SRP)
 - 클래스는 하나의 책임만 가져야 합니다. 즉, 클래스는 하나의 변경 사유만 가져야 합니다 1객체 = 1책임
 - 예시
```java
/**
 * 문제점: UserService 클래스는 사용자 등록, 이메일 발송, 보고서 생성이라는 
 * 여러 책임을 가지고 있습니다. 
 * 이러한 클래스는 변경이 자주 일어날 수 있으며, 각각의 책임이 독립적으로 변경되기 어려워집니다.
 */
public class UserService {
    public void registerUser(User user) {
        // 사용자 등록 로직
    }

    public void sendWelcomeEmail(User user) {
        // 환영 이메일 발송 로직
    }

    public void generateUserReport(User user) {
        // 사용자 보고서 생성 로직
    }
}

/**
 * 각 클래스가 하나의 책임만 갖게 되어, 변경의 이유가 하나로 제한됩니다. 
 * 예를 들어, 이메일 발송 로직이 변경되어도 사용자 등록 로직에 영향을 주지 않습니다.
 */
public class UserService {
    public void registerUser(User user) {
        // 사용자 등록 로직
    }
}

public class EmailService {
    public void sendWelcomeEmail(User user) {
        // 환영 이메일 발송 로직
    }
}

public class ReportService {
    public void generateUserReport(User user) {
        // 사용자 보고서 생성 로직
    }
}
```
### 2. 개방-폐쇄 원칙 (Open-Closed Principle, OCP)
 - 소프트웨어 개체는 확장에는 열려 있어야 하고, 수정에는 닫혀 있어야 합니다. 즉, 기능을 변경하지 않고 확장할 수 있어야 합니다.
 - 예시
```java
/**
 * AreaCalculator 클래스는 새로운 형태의 도형을 추가할 때마다 수정이 필요합니다. 
 * 이는 OCP 원칙에 위배됩니다.
*/
public class Shape {
    public enum Type { CIRCLE, SQUARE }

    public Type type;

    public Shape(Type type) {
        this.type = type;
    }
}

public class AreaCalculator {
    public double calculate(Shape shape) {
        return switch (shape.type) {
            case CIRCLE -> Math.PI * Math.pow(shape.radius, 2);
            case SQUARE -> Math.pow(shape.side, 2);
        };
    }
}

/**
 * 새로운 도형을 추가할 때 Shape 인터페이스를 구현한 새로운 클래스를 추가하면 되며, 
 * 기존 코드는 수정할 필요가 없습니다.
 */
public interface Shape {
    double calculateArea();
}

public class Circle implements Shape {
    private double radius;

    public Circle(double radius) {
        this.radius = radius;
    }

    @Override
    public double calculateArea() {
        return Math.PI * Math.pow(radius, 2);
    }
}

public class Square implements Shape {
    private double side;

    public Square(double side) {
        this.side = side;
    }

    @Override
    public double calculateArea() {
        return Math.pow(side, 2);
    }
}

public class AreaCalculator {
    public double calculate(Shape shape) {
        return shape.calculateArea();
    }
}

public class Main {
    public static void main(String[] args) {
        Shape circle = new Circle(5);
        Shape square = new Square(4);

        AreaCalculator calculator = new AreaCalculator();

        System.out.println("Circle area: " + calculator.calculate(circle));
        System.out.println("Square area: " + calculator.calculate(square));
    }
}
```
